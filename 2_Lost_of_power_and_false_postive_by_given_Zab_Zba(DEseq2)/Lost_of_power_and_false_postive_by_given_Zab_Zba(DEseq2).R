####################################################################################
#
# The R script has 2 simulation functions:
# 
# The first function will
#   generate random RNA-seq counts according to the genotype 
#   from negative binomial distribution for A and B genome in tetra-polyploid organism,  
#   and also has the swapped counts with the assigned A->B and B->A proportions. 
# 
# The second function will
#   create a matrix with simulated (true) RNA-seq counts as well as
#   the swapped counts ready for eQTL analysis by using Deseq2 package
#   
# Finally, the last part of the script is applying different combination of 
# parameter settings into previous two funcitons to determine the lose of power 
# and increase of false discover corresponding to each setting. 
#
#
#     University of Georgia
#     Insititute of Bioinformatics
# 
#                             Kang-Hsien Fan
#                                 01/21/2015
####################################################################################

###################################
###   Simulation function # 1   ###
###################################

####################################################################################
#
# Function name: Generate_Simulated_Data (Gen_Sim_Data)
# Description: 
#   Generate random RNA-seq counts according to the genotype 
#   from negative binomial distribution as the gene expression 
#   for A and B genome in tetra-polyploid organism,  
#   and also has the swapped counts with the assigned A->B and B->A proportions.
#   
# Parameters (default value):
#   mu_A_qq:  mean expression value for genome A with genotype qq (100)
#   mu_B_qq:  mean expression value for genome B with genotype qq (100)
#   theta:    over-dispersion parameter (1)
#   ss:       sample size for genotype qq (10)
#   HW_ratio: Hardy Weinberg Equilibrium ratio (1:2:1) 
#   fd_A:     fold changes for different genotypes in genome A (1)
#   fd_B:     fold changes for different genotypes in genome B (3)
#   prob_Zab: proportion of counts switch from A to B genome (0)
#   prob_Zba: proportion of counts switch from B to A genome (0)
#
# Output:
#
# A dataframe of both simulated (true) counts and swapped counts for A and B genome 
# with corresponding genotypes. The numbers of rows in dataframe are ss*HW_ratio. 
# Note that the genotypes are independent between A and B genome. 
#
# Dependance:
# rnegbin function in MASS package
#
####################################################################################

Gen_Sim_Data <- function(mu_A_qq=100,mu_B_qq=100,theta=1,
                         ss=10,HW_ratio=c(1,2,1),fd_A=1,fd_B=3,
                         prob_Zab=0,prob_Zba=0){
  
  ss <- ss*HW_ratio
  # calculate the sample sizes for each genotype (qq, qQ, QQ)
  mu_XA <- c(mu_A_qq,mu_A_qq*fd_A,mu_A_qq*(2*fd_A-1))
  # calcualte the mean expression value for genome A 
  # for each genotype (qq, qQ, QQ) according to assigned fold change (fd_A)
  mu_XB <- c(mu_B_qq,mu_B_qq*fd_B,mu_B_qq*(2*fd_B-1))
  # calcualte the mean expression value for genome B 
  # for each genotype (qq, qQ, QQ) according to assigned fold change (fd_B)
  
  GA_AA <- rnegbin(ss[1],mu_XA[1],theta)
  # generate RNA-seq counts for genotype qq in genome A 
  GA_AB <- rnegbin(ss[2],mu_XA[2],theta)
  # generate RNA-seq counts for genotype qQ in genome A 
  GA_BB <- rnegbin(ss[3],mu_XA[3],theta)
  # generate RNA-seq counts for genotype QQ in genome A 
  # All three sets of the random variables are generated by 
  # assigned over dispersion parameter, as well as 
  # the sample size & mean expression value for each corresponding genotype
  
  GT <- c(rep("AA",ss[1]),rep("AB",ss[2]),rep("BB",ss[3]))
  # generate a vector with genotypes with corresponding sample size
  
  GA_list <- c(GA_AA,GA_AB,GA_BB)
  # generate a vector with all simulated counts in genome A
  names(GA_list) <- GT
  # assign the genotype as the names for each simulated counts in genome A
  suffled_GA <- sample(GA_list)
  # suffle the vector of counts in genome A
  
  GB_AA <- rnegbin(ss[1],mu_XB[1],theta)
  # generate RNA-seq counts for genotype qq in genome B
  GB_AB <- rnegbin(ss[2],mu_XB[2],theta)
  # generate RNA-seq counts for genotype qQ in genome B
  GB_BB <- rnegbin(ss[3],mu_XB[3],theta)
  # generate RNA-seq counts for genotype QQ in genome B
  # All three sets of the random variables are generated by 
  # assigned over dispersion parameter, as well as 
  # the sample size & mean expression value for each corresponding genotype
  
  GB_list <- c(GB_AA,GB_AB,GB_BB)
  # generate a vector with all simulated counts in genome B
  names(GB_list) <- GT
  # assign the genotype as the names for each simulated counts in genome B
  suffled_GB <- sample(GB_list)
  # suffle the vector of counts in genome B
  
  d <- data.frame(GT_A=names(suffled_GA),true_A_counts=as.integer(suffled_GA),
                  GT_B=names(suffled_GB),true_B_counts=as.integer(suffled_GB))
  # generate a dataframe with each row represent as each individual and 
  # column 1: genotype in genome A
  # column 2: simulated counts in genome A
  # column 3: genotype in genome B
  # column 4: simulated counts in genome B
  
  d$sim_A_counts <- apply(d[,c("true_A_counts","true_B_counts")],1,function(x){
    as.integer(round(x[1]-x[1]*prob_Zab+x[2]*prob_Zba))
  })
  # calcualte the simulated counts in genome A 
  # by using assigned exchanging proportions (Zab & Zba)
  # and add it the the datafrome as the coulmn 5
  
  d$sim_B_counts <- d$true_B_counts+d$true_A_counts-d$sim_A_counts
  # calcualte the simulated counts in genome B
  # and add it the the datafrome as the coulmn 6
  
  return(d)
  # return the whole dataframe for later usage
}

###################################
###   Simulation function # 2   ###
###################################

####################################################################################
#
# Function name: Generate_DEseq2_matrix (Gen_DEseq2_matrix)
# Description: 
#   create a matrix with simulated (true) RNA-seq counts as well as
#   the swapped counts ready for eQTL analysis by using Deseq2 package
#   
# Parameters (default value):
#   mu_A_qq:  mean expression value for genome A with genotype qq (100)
#   mu_B_qq:  mean expression value for genome B with genotype qq (100)
#   theta:    over-dispersion parameter (1)
#   ss:       sample size for genotype qq (10)
#   HW_ratio: Hardy Weinberg Equilibrium ratio (1:2:1) 
#   fd_A:     fold changes for different genotypes in genome A (1)
#   fd_B:     fold changes for different genotypes in genome B (3)
#   prob_Zab: proportion of counts switch from A to B genome (0)
#   prob_Zba: proportion of counts switch from B to A genome (0)
#   n_rep:    numbers of replications (1000)
#
# Output:
#
# A dataframe of both simulated (true) counts and swapped counts for A and B genome 
# with corresponding genotypes. The numbers of rows in dataframe are ss*HW_ratio. 
# Note that the genotypes are independent between A and B genome. 
#
# Dependance:
# Gen_Sim_Data function in this script
#
####################################################################################

Gen_DEseq2_matrix <- function(mu_A_qq=100,mu_B_qq=100,theta=1,
                              ss=10,HW_ratio=c(1,2,1),fd_A=1,fd_B=3,
                              prob_Zab=0,prob_Zba=0,n_rep=1000){
  
  matrix_true_A <- matrix_true_B <- 
    matrix_sim_A <- matrix_sim_B <- 
    matrix_true_A_GT_B <- matrix_sim_A_GT_B <-
    matrix_true_B_GT_A <- matrix_sim_B_GT_A <-
    matrix(NA,ncol=sum(ss*HW_ratio),nrow=n_rep)
  # create 4 matrixes with number of rows are total sample size, 
  # and the numbers of columns are number of replicates to store 
  # a. ture counts in genome A
  # b. true counts in genome B
  # c. swapped counts in genome A
  # d. swapped counts in genome B
  
  for (i in 1:n_rep){
    # for each replicates, we will do:
    
    d <- Gen_Sim_Data(mu_A_qq=mu_A_qq,mu_B_qq=mu_B_qq,
                      ss=ss,HW_ratio=HW_ratio,fd_A=fd_A,fd_B=fd_B,
                      prob_Zab=prob_Zab,prob_Zba=prob_Zba)
    # call the Gen_Sim_Data function to generate the simulated read counts
    
    ind_GT_A <- order(d$GT_A)
    # get the genotype in genome A by its order. 
    # The Gen_Sim_Data will shuffle the genotypes, 
    # but we need store the counts by genotypes.
    
    matrix_true_A[i,] <- d[ind_GT_A,"true_A_counts"]
    matrix_sim_A[i,] <- d[ind_GT_A,"sim_A_counts"]
    # save the true counts and swapped counts in corresponding matrix by genotype
    
    matrix_true_B_GT_A[i,] <- d[ind_GT_A,"true_A_counts"]
    matrix_sim_B_GT_A[i,] <- d[ind_GT_A,"sim_A_counts"]
    # save the true counts and swapped counts in corresponding matrix by genotype
        
    ind_GT_B <- order(d$GT_B)
    # get the genotype in genome B by its order. 
    
    matrix_true_B[i,] <- d[ind_GT_B,"true_B_counts"]
    matrix_sim_B[i,] <- d[ind_GT_B,"sim_B_counts"]
    # save the true counts and swapped counts in corresponding matrix by genotype

    matrix_true_A_GT_B[i,] <- d[ind_GT_B,"true_A_counts"]
    matrix_sim_A_GT_B[i,] <- d[ind_GT_B,"sim_A_counts"]
    # save the true counts and swapped counts in corresponding matrix by genotype
    
  }
  
  rownames(matrix_true_A) <- paste("TA",1:n_rep,sep="")   
  rownames(matrix_true_B) <- paste("TB",1:n_rep,sep="")
  rownames(matrix_sim_A) <- paste("SA",1:n_rep,sep="")
  rownames(matrix_sim_B) <- paste("SB",1:n_rep,sep="")
  rownames(matrix_true_A_GT_B) <- paste("TA_GTB",1:n_rep,sep="")
  rownames(matrix_sim_A_GT_B) <- paste("SA_GTB",1:n_rep,sep="")
  rownames(matrix_true_B_GT_A) <- paste("TB_GTA",1:n_rep,sep="")
  rownames(matrix_sim_B_GT_A) <- paste("SB_GTA",1:n_rep,sep="")
  # assign the row names for each matrix either 
  # TA: true counts for genome A
  # TB: true counts for genome B
  # SA: swapped counts for genome A
  # SB: swapped counts for genome B
  
  gene_counts <- as.matrix(rbind(matrix_true_A,
                                 matrix_sim_A,
                                 matrix_true_B,
                                 matrix_sim_B,
                                 matrix_true_A_GT_B,
                                 matrix_sim_A_GT_B,
                                 matrix_true_B_GT_A,
                                 matrix_sim_B_GT_A))
  # create a merged matrix with all the counts data ready for DEseq2 analysis
  
  GT_names <- paste("GT",1:sum(ss*HW_ratio),sep="")
  # create a systematic names for each sample
  colnames(gene_counts) <- GT_names
  # assign the column names for gene count table 
  
  col_data <- data.frame(Genotype=factor(c(rep("AA",ss*HW_ratio[1]),
                                           rep("AB",ss*HW_ratio[2]),
                                           rep("BB",ss*HW_ratio[3])),
                                         levels=c("AA","AB","BB")))
  # create the required column data frame for DEseq2 analysis
  rownames(col_data) <- GT_names
  # assign row names for column data frame
  
  return(list(gene_counts=gene_counts,
              colData=col_data))
  # return 2 matrixes both ready for DEseq2 to do analysis
}

###################################
###   Main simulation process   ###
###################################

library(DESeq2)
library(MASS)
# load required packages for the simulation

n_rep <- 1000
# set numbers of replications 
ss <- 25
# numbers of sample size for genotype qq

mu_A <- mu_B <- c(100, 200, 1000)
# assign mean expression value for both A and B genome from 50 to 500
Zab <- Zba <- seq(0.1, 0.9, 0.1)
# set the exchange proportion form 0.1 to 0.9 by 0.1
fd <- seq(1.5,2.5,0.25)
# set the fold change in genome B from 1.5 to 2.5 by 0.25

paras <- expand.grid(Zab=Zab, Zba=Zba, mu_A=mu_A, mu_B=mu_B, fd=fd)
# create a matrix with all different combinations of parameters

# nrow(paras)

FDR_TA <- FDR_SA <- Power_TB <- Power_SB <- 
  FDR_TA_GTB <- FDR_SA_GTB <- Power_TB_GTA <- Power_SB_GTA <- rep(-1,nrow(paras))
# create 8 vectors to store the results of 
# false discovery rate and power before FDR adjustment
adj_FDR_TA <- adj_FDR_SA <- adj_Power_TB <- adj_Power_SB <- 
  adj_FDR_TA_GTB <- adj_FDR_SA_GTB <- adj_Power_TB_GTA <- adj_Power_SB_GTA <- rep(-1,nrow(paras))
# create 8 vectors to store the results of 
# false discovery rate and power after FDR adjustment

for(i in 1:nrow(paras)){
  # for each parameter setting
  
  print(i)
  # print current iteration to track process
  
  temp <- Gen_DEseq2_matrix(n_rep = n_rep, ss = ss, mu_A_qq = paras[i,"mu_A"],
                            mu_B_qq = paras[i,"mu_B"], fd_B = paras[i,"fd"],
                            prob_Zab = paras[i,"Zab"], prob_Zba = paras[i,"Zba"])
  # call Gen_DEseq2_matrix to generate 2 matrixes for DEseq2 analysis
  
  dds <- DESeqDataSetFromMatrix(countData=temp$gene_counts,
                                colData=temp$colData,
                                design= ~ Genotype)
  # DESeqDataSetFromMatrix function from DEseq2 to set experiment design
  
  normalFactors <- matrix(1,ncol=ncol(dds),nrow=nrow(dds),
                          dimnames = list(1:nrow(dds),1:ncol(dds)))
  # make an idendity matrix as the nomalization factors
  
  normalizationFactors(dds) <- normalFactors
  # assign the nomalization factor to be 1 
  
  DE_dds <- DESeq(dds, test="LRT", reduced = ~ 1, fitType="mean") 
  # find the differencial expressed genes by design (genotype)
  
  res_DE_dds <- results(DE_dds)
  # get the results form the model 
  
  ng <- nrow(res_DE_dds)
  # get number of rows of the result matrix
  
  FDR_TA[i] <- sum(res_DE_dds$pvalue[1:(ng/8)]<0.05)/(ng/8)
  FDR_SA[i] <- sum(res_DE_dds$pvalue[(ng/8+1):(ng/4)]<0.05)/(ng/8)
  Power_TB[i] <- sum(res_DE_dds$pvalue[(ng/4+1):(ng*3/8)]<0.05,na.rm = TRUE)/(ng/8)
  Power_SB[i] <- sum(res_DE_dds$pvalue[(ng*3/8+1):(ng/2)]<0.05,na.rm=TRUE)/(ng/8)
  FDR_TA_GTB[i] <- sum(res_DE_dds$pvalue[(ng/2+1):(5*ng/8)]<0.05,na.rm=TRUE)/(ng/8)
  FDR_SA_GTB[i] <- sum(res_DE_dds$pvalue[(5*ng/8+1):(3*ng/4)]<0.05,na.rm=TRUE)/(ng/8)
  Power_TB_GTA[i] <- sum(res_DE_dds$pvalue[(3*ng/4+1):(7*ng/8)]<0.05,na.rm=TRUE)/(ng/8)
  Power_SB_GTA[i] <- sum(res_DE_dds$pvalue[(7*ng/8+1):ng]<0.05,na.rm=TRUE)/(ng/8)
  # save the results of false discovery rate and power before the FDR adjustment
  
  adj_FDR_TA[i] <- sum(res_DE_dds$padj[1:(ng/8)]<0.05)/(ng/8)
  adj_FDR_SA[i] <- sum(res_DE_dds$padj[(ng/8+1):(ng/4)]<0.05)/(ng/8)
  adj_Power_TB[i] <- sum(res_DE_dds$padj[(ng/4+1):(ng*3/8)]<0.05,na.rm = TRUE)/(ng/8)
  adj_Power_SB[i] <- sum(res_DE_dds$padj[(ng*3/8+1):(ng/2)]<0.05,na.rm=TRUE)/(ng/8)
  adj_FDR_TA_GTB[i] <- sum(res_DE_dds$padj[(ng/2+1):(5*ng/8)]<0.05,na.rm=TRUE)/(ng/8)
  adj_FDR_SA_GTB[i] <- sum(res_DE_dds$padj[(5*ng/6+1):(3*ng/4)]<0.05,na.rm=TRUE)/(ng/8)
  adj_Power_TB_GTA[i] <- sum(res_DE_dds$padj[(3*ng/4+1):(7*ng/8)]<0.05,na.rm=TRUE)/(ng/8)
  adj_Power_SB_GTA[i] <- sum(res_DE_dds$padj[(7*ng/8+1):ng]<0.05,na.rm=TRUE)/(ng/8)
  # save the results of false discovery rate and power after the FDR adjustment
  
}

paras$col_mu <- ifelse(paras$mu_A==paras$mu_B, 1,ifelse(paras$mu_A>paras$mu_B,2,4))
# set the color to represent the ratio of the mu_A and mu_B
# black means mu_A = mu_B
# red means mu_A > mu_B
# blue means mu_A < mu_B
paras$col_fd <- sapply(paras$fd, function(x){which(x==unique(paras$fd))})
# set the color to represent the fold changes for genome B
# set black to fd = 1.5; red to fd = 1.75; green to fd = 2; 
# blue to fd = 2.25; light blue fd = 2.5

paras$MEV_ratio <- paras$mu_A/paras$mu_B

DEseq2_Sim_1_results <- cbind(paras,FDR_TA,FDR_SA,Power_TB,Power_SB,
                              FDR_TA_GTB,FDR_SA_GTB,
                              Power_TB_GTA,Power_SB_GTA,
                              adj_FDR_TA,adj_FDR_SA,
                              adj_Power_TB,adj_Power_SB,
                              adj_FDR_TA_GTB,adj_FDR_SA_GTB,
                              adj_Power_TB_GTA,adj_Power_SB_GTA)
# Merge all the results with the corresponding parameter settings.

rm(list=setdiff(ls(),"DEseq2_Sim_1_results"))
# remove all other objects
save.image("Loss_of_power_&_false_postive_with_different_Zab\Zba.RData")
# save the simulation result as an R image


